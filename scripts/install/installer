#!/usr/bin/env python3
from js9 import j
import netaddr
import click
import sys
import time

IMAGE_NAME = ''

AYSCONFIG = '''
metadata.jumpscale             =
    branch:'{version}',
    url:'git@github.com:jumpscale7/ays_jumpscale7',

metadata.openvcloud            =
    branch:'{ovcversion}',
    url:'git@github.com:0-complexity/openvcloud_ays',
'''

WHOAMI = '''
email                          =

fullname                       =

git.login                      = 'ssh'
git.passwd                     = 'ssh'
'''

class JumpScale7:
    def __init__(self, prefab):
        self.prefab = prefab

    def install_core(self, version='master', ovcversion='master'):
        env = {'AYSBRANCH': version, 'JSBRANCH': version}
        cmd = 'cd /tmp;rm -f install.sh;curl -k https://raw.githubusercontent.com/jumpscale7/jumpscale_core7/{}/install/install.sh > install.sh;bash install.sh'.format(version)
        self.prefab.system.ssh.define_host('git.aydo.com')
        self.prefab.system.ssh.define_host('github.com')

        if self.prefab.bash.cmdGetPath('python', False) is False or self.prefab.bash.cmdGetPath('curl', False) is False:
            self.prefab.system.package.mdupdate()
            self.prefab.system.package.install('python')
            self.prefab.system.package.install('curl')
        if self.prefab.bash.cmdGetPath('js', False) is False:
            self.prefab.core.run(cmd, env=env)
        self.prefab.core.file_write('/opt/jumpscale7/hrd/system/atyourservice.hrd', AYSCONFIG.format(version=version, ovcversion=ovcversion))
        self.prefab.core.file_write('/opt/jumpscale7/hrd/system/whoami.hrd', WHOAMI)

    def install_agent(self, osishost, osispassword, achost, gid):
        redisdata = {
            'param.disk': '0',
            'param.mem': '100',
            'param.passwd': '',
            'param.port': '9999',
            'param.ip' : '0.0.0.0',
            'param.unixsocket': '0'
        }
        self.ays_install('redis', instance='system', data=redisdata)

        osisclientdata = {
            'param.osis.client.addr': osishost,
            'param.osis.client.login': 'root',
            'param.osis.client.passwd': osispassword,
            'param.osis.client.port': '5544',
        }
        self.ays_install('osis_client', instance='main', data=osisclientdata)
        self.ays_install('osis_client', instance='jsagent', data=osisclientdata)

        agentcontrollerdata = {
            'agentcontroller.client.addr': achost,
            'agentcontroller.client.login': 'node',
            'agentcontroller.client.passwd': '',
            'agentcontroller.client.port': '4444'
        }
        self.ays_install('agentcontroller_client', instance='main', data=agentcontrollerdata)

        agentdata = {
                'agentcontroller.connection': 'main',
                'grid.id': str(gid),
                'grid.node.roles': 'node',
                'osis.connection': 'jsagent',
        }
        self.ays_install('jsagent', instance='main', data=agentdata)


    def ays_install(self, package, domain='jumpscale', instance='main', data=None):
        datastr = ''
        data = data or {}
        for key, value in data.items():
            datastr += "{}:{} ".format(key, value)
        cmd = 'ays install -d {} -n {} -i {} --data "{}"'.format(domain, package, instance, datastr)
        self.prefab.core.run(cmd)

    def install_compute_node(self, netinfo, masterhost, masterpassword, gid):
        data_net = {
            'netconfig.public_backplane.interfacename': 'backplane1',
            'netconfig.gw_mgmt_backplane.interfacename': 'backplane1',
            'netconfig.vxbackend.interfacename': 'backplane1',
            'netconfig.gw_mgmt.vlanid': netinfo['gwmgmt_vlan'],
            'netconfig.vxbackend.vlanid': netinfo['vxbackend_vlan'],
            'netconfig.gw_mgmt.ipaddr': netinfo['gwmgmt_ip'],
            'netconfig.vxbackend.ipaddr': netinfo['vxbackend_ip'],
        }

        data_cpu = {
            'param.rootpasswd': masterpassword,
            'param.master.addr': masterhost,
            'param.network.gw_mgmt_ip': netinfo['gwmgmt_ip'],
            'param.grid.id': gid,
        }

        print('installing network')
        self.ays_install('scaleout_networkconfig', domain='openvcloud', instance='main', data=data_net)

        print('installing cpu node')
        self.ays_install('cb_cpunode_aio', domain='openvcloud', instance='main', data=data_cpu)



    def install_compute_node(self, netinfo, masterhost, masterpassword, gid):
        data_net = {
            'netconfig.public_backplane.interfacename': 'backplane1',
            'netconfig.gw_mgmt_backplane.interfacename': 'backplane1',
            'netconfig.vxbackend.interfacename': 'backplane1',
            'netconfig.gw_mgmt.vlanid': netinfo['gwmgmt_vlan'],
            'netconfig.vxbackend.vlanid': netinfo['vxbackend_vlan'],
            'netconfig.gw_mgmt.ipaddr': netinfo['gwmgmt_ip'],
            'netconfig.vxbackend.ipaddr': netinfo['vxbackend_ip'],
        }

        data_cpu = {
            'param.rootpasswd': masterpassword,
            'param.master.addr': masterhost,
            'param.network.gw_mgmt_ip': netinfo['gwmgmt_ip'],
            'param.grid.id': gid,
        }

        print('installing network')
        self.ays_install('scaleout_networkconfig', domain='openvcloud', instance='main', data=data_net)

        print('installing cpu node')
        self.ays_install('cb_cpunode_aio', domain='openvcloud', instance='main', data=data_cpu)







###                    ###
# Command line interface #
###                    ###

@click.group()
def cli():
    pass

@cli.group()
def cluster():
    pass

@cli.group()
def node():
    pass

@cli.group()
def cpu():
    pass

@cli.group()
def storage():
    pass

@cluster.command('deploy')
@click.option('--config', help='Config file to deploy the cluster')
@click.option('--configure-cluster/--no-configure-cluster', help='Configure kubernetes cluster', default=True)
def deploy_cluster(config, configure_cluster):
    """
    Deploy will create the cluster machines and deploy kubernetes cluster on top of them.
    """
    if not config:
        raise j.exceptions.Input('Please specify a config file')
    if not j.clients.ssh.ssh_agent_available() or not j.clients.ssh.ssh_keys_list_from_agent():
        raise j.exceptions.NotFound ("No ssh key loaded. Please load the appropriate sshkey.")
    cluster = Cluster(config)
    if configure_cluster:
        cluster.install_kubernetes_cluster()
    cluster.install_controller()



@cpu.command('deploy')
@click.option('--config', help='Config file to deploy the cluster')
@click.option('--node-name', help='Node name to configure')
def deploy_cpu(config, node_name):
    config = j.data.serializer.yaml.load(config)
    for cpunode in config['nodes']['cpu']:
        if cpunode['name'] == node_name:
            break
    else:
        print('Could not find node with name {}'.format(node_name))
        sys.exit(1)

    ip = cpunode['mgmt']['ipaddress']
    prefab = j.tools.prefab.getFromSSH(ip)
    jumpscale = JumpScale7(prefab)
    versions = config['environment']['versions']
    password = config['environment']['password']
    gid = config['environment']['grid']['id']
    jumpscale.install_core(versions['jumpscale'], versions['openvcloud'])
    controllerips = []
    for host, interface in get_controller_host_management(config):
        controllerips.append(interface['ipaddress'])

    hostips = ','.join(controllerips)
    jumpscale.install_agent(hostips, password, hostips, gid)
    netinfo = {
        'vxbackend_vlan': config['network']['vlans']['vxbackend'],
        'vxbackend_ip': cpunode['vxbackend']['ipaddress'],
        'gwmgmt_vlan': config['network']['vlans']['gateway'],
        'gwmgmt_ip': cpunode['gwmgmt']['ipaddress'],

    }
    jumpscale.install_compute_node(netinfo, hostips, password, gid)


@storage.command('deploy')
@click.option('--config', help='Config file to deploy the cluster')
@click.option('--node-name', help='Node name to configure')
def deploy_storage(config, node_name):
    pass
    # WIP TODO
    # config = j.data.serializer.yaml.load(config)
    # for cpunode in config['nodes']['cpu']:
    #     if cpunode['name'] == node_name:
    #         break
    # else:
    #     print('Could not find node with name {}'.format(node_name))
    #     sys.exit(1)

    # ip = cpunode['mgmt']['ipaddress']
    # prefab = j.tools.prefab.getFromSSH(ip)
    # jumpscale = JumpScale7(prefab)
    # versions = config['environment']['versions']
    # password = config['environment']['password']
    # gid = config['environment']['grid']['id']
    # jumpscale.install_core(versions['jumpscale'], versions['openvcloud'])
    # controllerips = []
    # for host, interface in get_controller_host_management(config):
    #     controllerips.append(interface['ipaddress'])

    # hostips = ','.join(controllerips)
    # jumpscale.install_agent(hostips, password, hostips, gid)
    # netinfo = {
    #     'vxbackend_vlan': config['network']['vlans']['vxbackend'],
    #     'vxbackend_ip': cpunode['vxbackend']['ipaddress'],
    #     'gwmgmt_vlan': config['network']['vlans']['gateway'],
    #     'gwmgmt_ip': cpunode['gwmgmt']['ipaddress'],

    # }
    # jumpscale.install_compute_node(netinfo, hostips, password, gid)


def Build_images():
    """
    build the releveant images that will be used to run the deployments
    TODO
    """

def get_controller_host_management(config):
    for host in config['controller']['hosts']:
        for interface in host['network-interfaces']:
            if interface.get('label') == 'mgmt':
                yield host, interface

class Cluster:
    """
    Cluster abstraction layer to allow for easier manipulation.
    """
    def __init__(self, config_path):
        self.config = j.data.serializer.yaml.load(config_path)
        self.config_path = config_path
        self.k8s_config = '/tmp/kubelet.conf'
        self.join_line = ''
        self.prefab = j.tools.prefab.local
        self.nodes = self._nodes_prefab()

    def _nodes_prefab(self):
        nodes = []
        for host, interface in get_controller_host_management(self.config):
            sshclient = j.clients.ssh.get(interface['ipaddress'], login=host['user'], passwd=host['password'])
            sshkey = j.clients.ssh.ssh_keys_list_from_agent()[0]
            sshclient.SSHAuthorizeKey(j.sal.fs.getBaseName(sshkey))
            executor = j.tools.executor.getSSHBased(interface['ipaddress'], usecache=False)
            nodes.append(j.tools.prefab.get(executor))
        return nodes

    def _get_cidr(self):
        addr = self.nodes[0].executor.sshclient.addr
        net = netaddr.IPNetwork(addr)
        return str(net.cidr)

    def install_kubernetes_cluster(self):
        """
        Will install a kubernetes master and minion nodes on the first and rest of the node list respectively.
        """
        for node in self.nodes:
            node.core.run('swapoff -a')
        k8s_config_data , self.join_line = self.prefab.virtualization.kubernetes.multihost_install(self.nodes, unsafe=True)
        self.prefab.core.file_write(self.k8s_config, k8s_config_data)
        self.prefab.core.dir_ensure('/root/.kube')
        if not self.prefab.core.file_exists('/root/.kube/config'):
            self.prefab.core.file_write('/root/.kube/config', k8s_config_data)

    def install_controller(self):
        """
        Will use existing yaml or config scripts in this dir as well as jumpscale modules to install the controller setup on the
        cluster. Creating the relevant deployments, services, and mounts
        TODO
        """
        if not self.prefab.core.file_exists('/usr/local/bin/kubeclt'):
            self.prefab.virtualization.kubernetes.install_kube_client(location='/usr/local/bin/kubectl')
        directories = self.config['controller'].get('directories')
        for node in self.nodes:
            for directory in directories:
                node.core.dir_ensure(directory, mode='777')
        for key, value in self.config['environment']['ssl'].items():
            self.prefab.core.run('kubectl create secret generic {name}-certs --from-file {dir}'.format(name=key, dir=value['path']))
        self.kub_client_apply()

    def add_node(self, address):
        """
        Add new minion to cluster.

        @param address ,, str adress of the new node with format 'ip:port'
        """
        if not self.join_line:
            raise RuntimeError('cluster is not deployed. deploy cluster first to add new minions.')
        prefab = j.tools.prefab.get(address)
        prefab.virtualization.kubernetes.install_minion(self.join_line)

    # Not ready yet do not use
    def _apply_deploy(self, template):
        self.prefab.core.run('kubectl apply -f {template}'.format(template=template))
        template_name = j.sal.fs.getBaseName(template)
        timeout = time.time() + 240
        print('Waiting for deployment %s to be ready..' % template_name)
        while time.time() < timeout:
            _, out, _ = self.prefab.core.run('kubectl get deploy -o json')
            ready = False
            for item in out['items']:
                if item['metadata']['name'] == template_name:
                    if item['status'].get('readyReplicas') and item['status']['readyReplicas'] == item['state']['replicas']:
                        ready = True
                        break
            if ready:
                break
        else:
            raise j.exceptions.Timeout('Deploying %s took longer than expected. Exiting..')

    def _prepare_templates(self, scripts_dir):
        templates = ['agentcontroller', 'osis', 'nginx']
        for template in templates:
            template_loc = '{dir}{name}/{name}-service.yaml'.format(dir=scripts_dir,name=template)
            data = j.data.serializer.yaml.load(template_loc)
            data['spec']['externalIPs'] = [node.executor.sshclient.addr for node in self.nodes]
            j.data.serializer.yaml.dump(template_loc, data)
        stat_template = scripts_dir + '/stats-collector/stats-deployment.yaml'
        data = j.data.serializer.yaml.load(stat_template)
        data['spec']['template']['spec']['containers'][0]['args'][4] = self._get_cidr()
        j.data.serializer.yaml.dump(stat_template, data)

    def kub_client_apply(self, scripts_dir='/opt/code/github/0-complexity/openvcloud_installer/templates/'):
        self.prefab.core.copyTree('/opt/code/github/0-complexity/openvcloud_installer/scripts/kubernetes', scripts_dir)
        self._prepare_templates(scripts_dir)
        self.prefab.core.run('kubectl apply -f {path}/rbac.yaml'.format(path=scripts_dir))
        self.prefab.core.run('kubectl create configmap system-config --from-file {path}'.format(
                            path=self.config_path))
        templates = ['syncthing', 'mongocluster', 'influxdb', 'osis', 'agentcontroller', 'stats-collector', 'portal', 'nginx', 'pxeboot']
        for template in templates:
            template_file = scripts_dir + template
            self.prefab.core.run('kubectl apply -f {template}'.format(template=template_file))
        self.grafana_apply('{}/grafana'.format(scripts_dir))

    def grafana_apply(self, grafana_dir):
        cmd = """
        cd {dir}
        kubectl create configmap grafana-provisioning-datasources --from-file=provisioning/datasources
        kubectl create configmap grafana-provisioning-dashboards --from-file=provisioning/dashboards
        kubectl create configmap grafana-dashboards --from-file=sources/templates
        kubectl apply -f grafana-service.yaml
        kubectl  apply -f grafana-deployment.yaml
        """.format(dir=grafana_dir)
        self.prefab.core.execute_bash(cmd)

if __name__ == '__main__':
    cli()


